{"version":3,"sources":["../src/adaptive-grid.jsx"],"names":["AdaptiveGridItem","props","childStyle","children","AdaptiveGrid","gridStyle","overflow","position","canCalculate","getFilteredChildren","totalColumns","getTotalColumns","colWidth","getColWidth","sizes","getItemSizes","coords","getItemCoordinates","applyItemStyles","height","getGridMaxHeight","visibility","baseWidth","baseHeight","console","error","onResize","state","width","bind","setState","forEach","child","type","push","maxColumns","Infinity","Math","max","min","floor","map","minWidth","minHeight","ceil","remainingElements","slice","call","remainingElementsIds","Object","keys","row","boundaries","length","col","elId","childId","cols","rows","isFilled","doFill","splice","i","left","top","maxRow","Component","colStart","rowStart","colEnd","rowEnd","arr","borders","colStart2","rowStart2","colEnd2","rowEnd2"],"mappings":"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","file":"adaptive-grid.js","sourcesContent":["/**\r\n * @license MIT\r\n * @copyright Kirill Shestakov 2017\r\n * @see https://github.com/guitarino/adaptive-grid--react/\r\n */\r\n\r\nimport React from 'react';\r\nimport ResizeSensor from 'resize-sensor--react';\r\n\r\nexport function AdaptiveGridItem(props) {\r\n  return (\r\n    <div className=\"AdaptiveGridItem\" style={props.childStyle}>\r\n      {props.children}\r\n    </div>\r\n  )\r\n};\r\n\r\nexport class AdaptiveGrid extends React.Component {\r\n  render() {\r\n    var\r\n      children = []\r\n    ,\r\n      gridStyle = {\r\n        overflow: 'visible',\r\n        position: 'relative'\r\n      }\r\n    ;\r\n    if (this.canCalculate()) {\r\n      children = this.getFilteredChildren();\r\n      var\r\n        totalColumns = this.getTotalColumns()\r\n      ,\r\n        colWidth = this.getColWidth(totalColumns)\r\n      ,\r\n        sizes = this.getItemSizes(children, totalColumns)\r\n      ,\r\n        coords = this.getItemCoordinates(children, sizes, totalColumns)\r\n      ,\r\n        children = this.applyItemStyles(children, colWidth, sizes, coords)\r\n      ;\r\n      gridStyle.height = this.getGridMaxHeight(children, sizes, coords) + 'px';\r\n    }\r\n    else {\r\n      gridStyle.visibility = 'hidden';\r\n      if (!(\r\n        this.props.baseWidth > 0 &&\r\n        this.props.baseHeight > 0\r\n      )) {\r\n        console.error('Base width and base height should be provided and be positive');\r\n      }\r\n    }\r\n    return (\r\n      <div className='AdaptiveGrid' style={ gridStyle }>\r\n        <ResizeSensor onResize={ this.onResize } />\r\n        { children }\r\n      </div>\r\n    );\r\n  }\r\n  \r\n  componentWillMount() {\r\n    this.state = { width: 0 };\r\n    this.onResize = this.onResize.bind(this);\r\n  }\r\n  \r\n  // callback from resize-sensor\r\n  onResize(width) {\r\n    if (this.state.width !== width) {\r\n      this.setState({width: width});\r\n    }\r\n  }\r\n\r\n  // this is to ignore children that are not AdaptiveGridItem\r\n  getFilteredChildren() {\r\n    var children = [];\r\n    this.props.children.forEach((child) => {\r\n      if(child.type === AdaptiveGridItem) {\r\n        children.push(child);\r\n      }\r\n    });\r\n    return children;\r\n  }\r\n\r\n  // if calculation can happen without error, returns true\r\n  canCalculate() {\r\n    return (\r\n      this.state.width > 0 &&\r\n      this.props.baseWidth > 0 &&\r\n      this.props.baseHeight > 0\r\n    );\r\n  }\r\n\r\n  // also account for max columns\r\n  getTotalColumns() {\r\n    let maxColumns = this.props.maxColumns ? this.props.maxColumns : Infinity;\r\n    return Math.max(1, Math.min(maxColumns, Math.floor(this.state.width / this.props.baseWidth)));\r\n  }\r\n\r\n  getColWidth(totalColumns) {\r\n    return this.state.width / totalColumns;\r\n  }\r\n\r\n  getItemSizes(children, totalColumns) {\r\n    return children.map((child) => {\r\n      var\r\n        width = this.props.baseWidth\r\n      ,\r\n        height = this.props.baseHeight\r\n      ;\r\n      if(child.props) {\r\n        if(child.props.minWidth) {\r\n          width = child.props.minWidth;\r\n        }\r\n        if(child.props.minHeight) {\r\n          height = child.props.minHeight;\r\n        }\r\n      }\r\n      return [\r\n        Math.min(totalColumns, Math.ceil(width / this.props.baseWidth)),\r\n        Math.ceil(height / this.props.baseHeight)\r\n      ];\r\n    });\r\n  }\r\n\r\n  getItemCoordinates(children, sizes, totalColumns) {\r\n    var\r\n      remainingElements = [].slice.call(children)\r\n    ,\r\n    // remainingElementsIds is in sync with remainingElements so that\r\n    // we don't have to search for indeces every time\r\n      remainingElementsIds = Object.keys(children)\r\n    ,\r\n      coords = []\r\n    ,\r\n      row = 0\r\n    ,\r\n      boundaries = [] // array for boundaries of current grid items\r\n    ;\r\n    // filling up the grid and removing remainingElements until none left\r\n    while(remainingElements.length) {\r\n      for(var col = 0; col < totalColumns; col++) {\r\n        for(var elId = 0; elId < remainingElements.length; elId++) {\r\n          var\r\n            childId = remainingElementsIds[elId]\r\n          ,\r\n            [cols, rows] = sizes[childId]\r\n          ;\r\n          // if not exceeding the boundary\r\n          if(col + cols <= totalColumns) {\r\n            // and if other items are not in the way\r\n            if(!isFilled(col, row, col + cols, row + rows, boundaries)) {\r\n              // then the current item can claim those coordinates\r\n              coords[childId] = [col, row];\r\n              // and, don't forget to update the filled space\r\n              doFill(col, row, col + cols, row + rows, boundaries);\r\n              // now, there's 1 less item remaining\r\n              remainingElements.splice(elId, 1);\r\n              remainingElementsIds.splice(elId, 1);\r\n              elId--; // since we removed an element, we gotta go back by 1 id\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      row++;\r\n    }\r\n    return coords;\r\n  }\r\n\r\n  applyItemStyles(children, colWidth, sizes, coords) {\r\n    return children.map((child, i) => (\r\n      <AdaptiveGridItem\r\n        {...child.props}\r\n        key={i}\r\n        childStyle={{\r\n          position: 'absolute',\r\n          left: coords[i][0] * colWidth + 'px',\r\n          top: coords[i][1] * this.props.baseHeight + 'px',\r\n          width: sizes[i][0] * colWidth + 'px',\r\n          height: sizes[i][1] * this.props.baseHeight + 'px'\r\n        }}\r\n      >\r\n        {child.props.children}\r\n      </AdaptiveGridItem>\r\n    ));\r\n  }\r\n\r\n  getGridMaxHeight(children, sizes, coords) {\r\n    var maxRow = 0;\r\n    children.forEach((child, i) => {\r\n      var\r\n        [col, row] = coords[i]\r\n      ,\r\n        [cols, rows] = sizes[i]\r\n      ;\r\n      if (row + rows > maxRow) {\r\n        maxRow = row + rows;\r\n      }\r\n    });\r\n    return maxRow * this.props.baseHeight;\r\n  }\r\n}\r\n\r\n// checks if the provided coordinates and sizes for an item\r\n// will overlap with currently placed items\r\nfunction isFilled(colStart, rowStart, colEnd, rowEnd, arr) {\r\n  var isFilled = false;\r\n  arr.forEach((borders) => {\r\n    var [colStart2, rowStart2, colEnd2, rowEnd2] = borders;\r\n    if (colStart < colEnd2 && colEnd > colStart2 &&\r\n      rowEnd2 > rowStart && rowStart2 < rowEnd ) {\r\n      isFilled = true;\r\n      return false;\r\n    }\r\n  });\r\n  return isFilled;\r\n}\r\n\r\n// adds provided coordinates and sizes as a currently placed item\r\nfunction doFill(colStart, rowStart, colEnd, rowEnd, arr) {\r\n  arr.push([colStart, rowStart, colEnd, rowEnd]);\r\n}"]}