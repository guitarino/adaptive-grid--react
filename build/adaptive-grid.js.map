{"version":3,"sources":["../src/adaptive-grid.jsx"],"names":["AdaptiveGridItem","props","childStyle","children","AdaptiveGrid","state","width","onResize","bind","getFilteredChildren","gridStyle","overflow","position","canCalculate","totalColumns","getTotalColumns","colWidth","getColWidth","sizes","getItemSizes","coords","getItemCoordinates","applyItemStyles","height","getGridMaxHeight","visibility","baseWidth","baseHeight","console","error","setState","forEach","child","type","push","maxColumns","Infinity","Math","max","min","floor","map","minWidth","minHeight","ceil","remainingElements","slice","call","remainingElementsIds","Object","keys","row","boundaries","length","col","elId","childId","cols","rows","isFilled","doFill","splice","i","left","top","maxRow","Component","colStart","rowStart","colEnd","rowEnd","arr","borders","colStart2","rowStart2","colEnd2","rowEnd2"],"mappings":"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","file":"adaptive-grid.js","sourcesContent":["/**\n * @license MIT\n * @copyright Kirill Shestakov 2017\n * @see https://github.com/guitarino/adaptive-grid--react/\n */\n\nimport React from 'react';\nimport ResizeSensor from 'resize-sensor--react';\n\nexport function AdaptiveGridItem(props) {\n  return (\n    <div className=\"AdaptiveGridItem\" style={props.childStyle}>\n      {props.children}\n    </div>\n  )\n};\n\nexport class AdaptiveGrid extends React.Component {\n  constructor() {\n    super();\n    this.state = { width: 0 };\n    this.onResize = this.onResize.bind(this);\n  }\n\n  render() {\n    var children = this.getFilteredChildren();\n    var gridStyle = {\n      overflow: 'visible',\n      position: 'relative'\n    };\n    if (this.canCalculate()) {\n      var totalColumns = this.getTotalColumns();\n      var colWidth = this.getColWidth(totalColumns);\n      var sizes = this.getItemSizes(children, totalColumns);\n      var coords = this.getItemCoordinates(children, sizes, totalColumns);\n      children = this.applyItemStyles(children, colWidth, sizes, coords);\n      gridStyle.height = this.getGridMaxHeight(children, sizes, coords) + 'px';\n    }\n    else {\n      gridStyle.visibility = 'hidden';\n      if (!(\n        this.props.baseWidth > 0 &&\n        this.props.baseHeight > 0\n      )) {\n        console.error('Base width and base height should be provided and be positive');\n      }\n    }\n    return (\n      <div className='AdaptiveGrid' style={ gridStyle }>\n        <ResizeSensor onResize={ this.onResize } />\n        { children }\n      </div>\n    );\n  }\n  \n  // callback from resize-sensor\n  onResize(width) {\n    if (this.state.width !== width) {\n      this.setState({width: width});\n    }\n  }\n\n  // this is to ignore children that are not AdaptiveGridItem\n  getFilteredChildren() {\n    var children = [];\n    this.props.children.forEach((child) => {\n      if(child.type === AdaptiveGridItem) {\n        children.push(child);\n      }\n    });\n    return children;\n  }\n\n  // if calculation can happen without error, returns true\n  canCalculate() {\n    return (\n      this.state.width > 0 &&\n      this.props.baseWidth > 0 &&\n      this.props.baseHeight > 0\n    );\n  }\n\n  // also account for max columns\n  getTotalColumns() {\n    let maxColumns = this.props.maxColumns ? this.props.maxColumns : Infinity;\n    return Math.max(1, Math.min(maxColumns, Math.floor(this.state.width / this.props.baseWidth)));\n  }\n\n  getColWidth(totalColumns) {\n    return this.state.width / totalColumns;\n  }\n\n  getItemSizes(children, totalColumns) {\n    return children.map((child) => {\n      var width = this.props.baseWidth;\n      var height = this.props.baseHeight;\n      if(child.props) {\n        if(child.props.minWidth) {\n          width = child.props.minWidth;\n        }\n        if(child.props.minHeight) {\n          height = child.props.minHeight;\n        }\n      }\n      return [\n        Math.min(totalColumns, Math.ceil(width / this.props.baseWidth)),\n        Math.ceil(height / this.props.baseHeight)\n      ];\n    });\n  }\n\n  getItemCoordinates(children, sizes, totalColumns) {\n    var remainingElements = [].slice.call(children);\n    // remainingElementsIds is in sync with remainingElements so that\n    // we don't have to search for indeces every time\n    var remainingElementsIds = Object.keys(children);\n    var coords = [];\n    var row = 0;\n    var boundaries = []; // array for boundaries of current grid items\n    // filling up the grid and removing remainingElements until none left\n    while(remainingElements.length) {\n      for(var col = 0; col < totalColumns; col++) {\n        for(var elId = 0; elId < remainingElements.length; elId++) {\n          var childId = remainingElementsIds[elId];\n          var [cols, rows] = sizes[childId];\n          // if not exceeding the boundary\n          if(col + cols <= totalColumns) {\n            // and if other items are not in the way\n            if(!isFilled(col, row, col + cols, row + rows, boundaries)) {\n              // then the current item can claim those coordinates\n              coords[childId] = [col, row];\n              // and, don't forget to update the filled space\n              doFill(col, row, col + cols, row + rows, boundaries);\n              // now, there's 1 less item remaining\n              remainingElements.splice(elId, 1);\n              remainingElementsIds.splice(elId, 1);\n              elId--; // since we removed an element, we gotta go back by 1 id\n              break;\n            }\n          }\n        }\n      }\n      row++;\n    }\n    return coords;\n  }\n\n  applyItemStyles(children, colWidth, sizes, coords) {\n    return children.map((child, i) => (\n      <AdaptiveGridItem\n        key={i}\n        childStyle={{\n          position: 'absolute',\n          left: coords[i][0] * colWidth + 'px',\n          top: coords[i][1] * this.props.baseHeight + 'px',\n          width: sizes[i][0] * colWidth + 'px',\n          height: sizes[i][1] * this.props.baseHeight + 'px'\n        }}\n      >\n        {child.props.children}\n      </AdaptiveGridItem>\n    ));\n  }\n\n  getGridMaxHeight(children, sizes, coords) {\n    var maxRow = 0;\n    children.forEach((child, i) => {\n      var [col, row] = coords[i];\n      var [cols, rows] = sizes[i];\n      if (row + rows > maxRow) {\n        maxRow = row + rows;\n      }\n    });\n    return maxRow * this.props.baseHeight;\n  }\n}\n\n// checks if the provided coordinates and sizes for an item\n// will overlap with currently placed items\nfunction isFilled(colStart, rowStart, colEnd, rowEnd, arr) {\n  var isFilled = false;\n  arr.forEach((borders) => {\n    var [colStart2, rowStart2, colEnd2, rowEnd2] = borders;\n    if (colStart < colEnd2 && colEnd > colStart2 &&\n      rowEnd2 > rowStart && rowStart2 < rowEnd ) {\n      isFilled = true;\n      return false;\n    }\n  });\n  return isFilled;\n}\n\n// adds provided coordinates and sizes as a currently placed item\nfunction doFill(colStart, rowStart, colEnd, rowEnd, arr) {\n  arr.push([colStart, rowStart, colEnd, rowEnd]);\n}"]}